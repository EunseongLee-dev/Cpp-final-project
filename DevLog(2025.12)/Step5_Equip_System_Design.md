
# 📌 C++ 파이널 프로젝트 — 5단계 장착 시스템 구현 정리

## 1. 단계 개요
이번 5단계에서는 기존 **Item / Inventory / Player 구조(4단계 완료 상태)** 를 유지한 채,
새로운 **장착 시스템(Weapon / Armor)** 을 추가하는 것이 목표였다.

핵심 포인트는 다음과 같다.

- Item 기반 상속 구조 유지
- Inventory의 `unique_ptr<Item>` 소유권 구조를 깨지 않기
- Player가 장착 상태를 관리하되, 아이템 생명주기는 Inventory와 연동
- 장착/해제 시 스탯 반영

---

## 2. 클래스 구조 확장

### 🔹 Item (기존)
- 이름, 타입, 수치(Value) 보유
- 모든 아이템의 공통 부모 클래스

추가된 인터페이스 개념:
- `IsEquipable()` : 착용 가능 여부 판단 (가상 함수 개념)

---

### 🔹 Weapon : public Item
**역할**
- 공격력 증가 장비

**주요 멤버**
- `AtkUP` : 장착 시 증가할 공격력 수치

**주요 함수**
- `Weapon(...)` : Item 생성자 호출 + 공격력 보너스 초기화
- `IsEquipable()` : 항상 true 반환 (장비 아이템)
- `GetATKBonus()` : 공격력 증가 수치 반환

---

### 🔹 Armor : public Item
**역할**
- 최대 체력 증가 장비

**주요 멤버**
- `HpUP` : 장착 시 증가할 체력 수치

**주요 함수**
- `Armor(...)` : Item 생성자 호출 + 체력 보너스 초기화
- `IsEquipable()` : 항상 true 반환
- `GetHpBonus()` : 체력 증가 수치 반환

---

## 3. Player 클래스 확장

### 🔹 추가된 멤버 변수
- `std::unique_ptr<Weapon> equippedWeapon`
- `std::unique_ptr<Armor> equippedArmor`
- `BaseATK`, `BaseMaxHp`
  - 장비 해제 시 원래 스탯 복구를 위한 기준값

---

### 🔹 장착 관련 주요 함수

#### `EquipItemFromInventory(int index)`
**역할**
- 인벤토리에서 아이템 선택
- 착용 가능 여부 판단
- 무기 / 방어구 타입 분기 처리
- 이미 장착 중일 경우 사용자 선택 처리

**현재 특징**
- 장착 판단, 메뉴 출력, 해제 처리까지 모두 담당
- 기능이 다소 과밀한 상태

---

#### `UnequipWeapon()`
- 공격력을 기본값으로 복구
- 장착 중이던 무기를 다시 인벤토리로 반환

#### `UnequipArmor()`
- 최대 체력을 기본값으로 복구
- 장착 중이던 방어구를 인벤토리로 반환

---

## 4. 현재 구조의 장점

- 기존 Inventory의 `unique_ptr<Item>` 구조를 깨지 않음
- 장착 아이템도 명확한 소유권 이동 흐름 유지
- 장비/소모 아이템의 역할 분리가 명확해짐
- 메모리 누수 없이 장착/해제 구현

---

## 5. 아쉬운 점 및 개선 예정 사항

### ❗ Player의 책임 과다
- `EquipItemFromInventory()` 함수가 너무 많은 역할을 수행
  - 입력 처리
  - 타입 판단
  - 장착 여부 확인
  - 해제 처리
  - 실제 스탯 반영

➡️ **추후 개선 방향**
- 장착 판단 로직 분리
- 장착 / 교체 / 해제 전용 함수 분리
- Player는 “장착 상태 관리”에만 집중하도록 책임 축소

---

### ❗ Item 타입 문자열 의존
- `"Weapon"`, `"Armor"` 문자열 비교 사용 중

➡️ **추후 개선 방향**
- enum class 기반 ItemType 도입
- 타입 안정성 강화

---

## 6. 다음 단계 예고

- 장착 시스템 리팩토링
- 장착 로직과 UI 로직 분리
- 장비 효과 계산 전용 함수 분리
- 언리얼 엔진 구조를 고려한 컴포넌트화 준비

---

## ✅ 정리
이번 5단계는 **“완성도”보다는 “구조 실험 단계”** 로,
스마트 포인터 기반 설계와 책임 분리의 중요성을 직접 체감하는 단계였다.

이후 단계에서는 **기능 분해와 구조 개선**을 중심으로 확장할 예정이다.
